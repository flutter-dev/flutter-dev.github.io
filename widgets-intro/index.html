<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>A Tour of the Flutter Widget Framework  - Flutter </title>
  <link rel="shortcut icon" href="/images/favicon.png">

  <meta name="description" content="">
  <meta name="keywords" content=" ">

  <link rel="stylesheet" href="/css/lavish-bootstrap.css">
  <link rel="stylesheet" href="/css/main.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Extended" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro%7CRoboto:500,400italic,300,400" rel="stylesheet">
  
  <link rel="canonical" href="http://localhost:4000/widgets-intro/">

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67589403-1', 'auto');
    ga('send', 'pageview');
  </script>

  <meta name="google-site-verification" content="HFqxhSbf9YA_0rBglNLzDiWnrHiK_w4cqDh2YD2GEY4" />
</head>


  <body class="">

    <div id="overlay-under-drawer"><!-- for the drawer on narrow screens --></div>

    <header class="site-header">
  <div class="container-fluid header-contents">
    <div class="row">
      <div class="col-md-12">
        <i class="fa fa-bars" id="sidebar-toggle-button" aria-hidden="true" style="display:none"></i>
        <img src="/images/flutter-mark-square-100.png" alt="Flutter Logo" width="40" height="40" style="vertical-align:middle">

        <a class="site-title" href="/">Flutter</a>

        <nav class="site-nav">
          <a href="#" class="menu-icon">
            <i class="material-icons-extended">more_vert</i>
          </a>
          <div class="trigger">
            <a class="page-link" href="/docs/">文档</a>
            <a class="page-link" href="https://github.com/flutter/flutter">GitHub</a>
            <a class="page-link" href="https://pub.dartlang.org/flutter">库</a>
            <a class="page-link" href="/support/">支持</a>
            <a class="page-link" href="http://flutter-dev.cn">论坛</a>
            <form action="/search/" class="nav-searchbox" id="cse-search-box" style="display: inline">
              <input type="hidden" name="cx" value="007067728241810524621:gm6vraqlc8c">
              <input type="hidden" name="ie" value="UTF-8">
              <input type="hidden" name="hl" value="en">
              <input type="search" name="q" id="q" autocomplete="off" placeholder="搜索">
            </form>
          </div>
        </nav>
      </div>
    </div> <!-- /.row -->
  </div> <!-- /.container -->
</header>


    <!-- Page Content -->
    <div class="container-fluid contents">
      <!-- Content Row -->
      <div class="row">

        <!-- Sidebar Column -->
        <div id="side-nav-container" class="col-sm-3">
          <ul id="mysidebar" class="nav">

  <li class="sidebar-title">入门</li>

    <ul class="sidebar-items">
      <li><a href="/get-started/install/">1: 安装</a></li>
      <li><a href="/get-started/editor/">2: 配置编辑器</a></li>
      <li><a href="/get-started/test-drive/">3: 试运行</a></li>
      <li><a href="/get-started/codelab/">4: 编写第一个 Flutter 应用</a></li>
      <li><a href="/get-started/learn-more/">5: 学习更多</a></li>
    </ul>

  <li class="sidebar-title">构建 UI</li>

    <ul class="sidebar-items">
      <li><a href="/widgets-intro/">框架预览</a></li>
      <li><a href="/widgets/">Widget 目录</a></li>
      <li><a href="/cookbook/">小案例</a></li>
      <li><a href="/catalog/samples/">示例目录</a></li>
      <li><a href="https://codelabs.developers.google.com/codelabs/flutter/index.html#0">构建漂亮的用户界面 - Codelab</a></li>
      <li><a href="/tutorials/layout/">构建布局 - 教程</a></li>
      <li><a href="/tutorials/interactive/">添加交互 - 教程</a></li>
      <li><a href="/web-analogs/">HTML/CSS 模式</a></li>
      <li><a href="/flutter-for-android/">Android 开发者参考</a></li>
      <li><a href="/flutter-for-react-native/">React Native 开发者参考</a></li>
      <li><a href="/gestures/">手势</a></li>
      <li><a href="/animations/">动画</a></li>
      <li><a href="/custom-fonts/">自定义字体</a></li>
      <li><a href="/layout/">框约束</a></li>
      <li><a href="/assets-and-images/">资源与图像</a></li>
      <li><a href="/text-input/">文本输入</a></li>
      <li><a href="/routing-and-navigation/">界面路由与导航</a></li>
      <li><a href="/tutorials/internationalization">国际化</a></li>
    </ul>

  <li class="sidebar-title">使用设备与 SDK 中的 API</li>

    <ul class="sidebar-items">
      <li><a href="/using-packages/">使用扩展包</a></li>
      <li><a href="/developing-packages/">开发扩展包</a></li>
      <li><a href="/platform-channels/">平台特定代码</a></li>
      <li><a href="/reading-writing-files/">文件的读写</a></li>
      <li><a href="/networking/">网络和 HTTP</a></li>
      <li><a href="/json/">JSON 和序列化</a></li>
      
    </ul>

  <li class="sidebar-title">开发与工具</li>

    <ul class="sidebar-items">
      <li><a href="/using-ide/">Flutter IDE 的使用</a></li>
      <li><a href="/hot-reload/">热重载的使用</a></li>
      <li><a href="/testing/">应用测试</a></li>
      <li><a href="/debugging/">应用调试</a></li>
      <li><a href="/inspector/">用户界面检查</a></li>
      <li><a href="/android-release/">编译正式版的 Android 应用</a></li>
      <li><a href="/ios-release/">编译正式版的 iOS 应用</a></li>
      <li><a href="/upgrading/">升级 Flutter</a></li>
      <li><a href="/formatting/"> 格式化代码</a></li>
    </ul>

  <li class="sidebar-title">更多细节</li>

    <ul class="sidebar-items">
      <li><a href="/faq/">FAQ</a></li>
      <li><a href="/technical-overview">技术一览</a></li>
      <li><a href="https://docs.google.com/presentation/d/1B3p0kP6NV_XMOimRV09Ms75ymIjU5gr6GGIX74Om_DE/edit?usp=sharing">神奇的 Flutter - 幻灯片</a></li>
      <li><a href="https://docs.google.com/presentation/d/1cw7A4HbvM_Abv320rVgPVGiUP2msVs7tfGbkgdrTy0I/edit?usp=sharing">架构图</a></li>
      <li><a href="https://www.bilibili.com/video/av14430321/">Flutter 框架层设计 <i class="fa fa-video-camera" aria-hidden="true"></i></a></li>
      <li><a href="https://www.bilibili.com/video/av6269773/">Flutter 的渲染管线 <i class="fa fa-video-camera" aria-hidden="true"></i></a></li>
    </ul>

</ul>

        </div>

        
        

        <!-- Content Column -->
        <div class="col-sm-9 main-contents">
          <div class="main-contents-body">
            <article class="post-content">
  
  
  <header class="post-header">
      <div class="btn-group contribute" role="group">
         <a href="https://github.com/flutter/website/blob/master/zh_CN/widgets-intro.md" class="btn btn-sm">
            <i class="fa fa-pencil"></i> Edit Source
         </a>
         <a href="https://github.com/flutter/flutter/issues/new?title=Issue from website page A Tour of the Flutter Widget Framework&body=From URL: http://localhost:4000/widgets-intro/&labels=dev: docs - website" class="btn btn-sm">
            <i class="fa fa-github"></i> File Issue
        </a>
     </div>
   <div>
    <h1 class="post-title">A Tour of the Flutter Widget Framework </h1>
   </div>

  </header>
  

  <ul id="markdown-toc">
  <li><a href="#简介" id="markdown-toc-简介">简介</a></li>
  <li><a href="#hello-world" id="markdown-toc-hello-world">Hello World</a></li>
  <li><a href="#basic-widgets" id="markdown-toc-basic-widgets">Basic widgets</a></li>
  <li><a href="#使用-material-components" id="markdown-toc-使用-material-components">使用 Material Components</a></li>
  <li><a href="#手势的处理" id="markdown-toc-手势的处理">手势的处理</a></li>
  <li><a href="#更改-widgets-显示状态" id="markdown-toc-更改-widgets-显示状态">更改 widgets 显示状态</a></li>
  <li><a href="#综合实例" id="markdown-toc-综合实例">综合实例</a></li>
  <li><a href="#widget-的生命周期" id="markdown-toc-widget-的生命周期">widget 的生命周期</a></li>
  <li><a href="#keys" id="markdown-toc-keys">Keys</a></li>
  <li><a href="#全局-keys" id="markdown-toc-全局-keys">全局 Keys</a></li>
</ul>

<h2 id="简介">简介</h2>
<p>Flutter widgets 启发于 
<a href="http://facebook.github.io/react/">React</a>，使用流行的响应式框架构建。你可以使用 widgets 去组装出你想要的 UI。用组件来构建整个页面以及显示当前的信息状态。当某 widget 的 state 发生变化时，该 widget 会重新构建加载，Flutter 会比较当前 state 与前面的 state，确保以最小的更改来达到当前所需要的 state。</p>

<aside id="note" class="alert alert-info">
  <p><strong>注意：</strong> 如果你想更深入的了解 Flutter 并想查看某些代码, 请移步
<a href="/tutorials/layout/">Building Layouts in Flutter</a> 和
<a href="/tutorials/interactive/">Adding Interactivity to Your Flutter App</a>.</p>
</aside>

<h2 id="hello-world">Hello World</h2>
<p>再小的 Flutter 应用程序也需要调用 
<a href="https://docs.flutter.io/flutter/widgets/runApp.html"><code class="highlighter-rouge">runApp</code></a> 函数：</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="s">'package:flutter/material.dart'</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">runApp</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">Center</span><span class="o">(</span>
      <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span>
        <span class="s">'Hello, world!'</span><span class="o">,</span>
        <span class="nl">textDirection:</span> <span class="n">TextDirection</span><span class="o">.</span><span class="na">ltr</span><span class="o">,</span>
      <span class="o">),</span>
    <span class="o">),</span>
  <span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>

<p><a href="https://docs.flutter.io/flutter/widgets/runApp.html"><code class="highlighter-rouge">runApp</code></a> 函数是 
<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html"><code class="highlighter-rouge">Widget</code></a> 的入口函数。在这个小例子中，有两个 widget，及 
<a href="https://docs.flutter.io/flutter/widgets/Center-class.html"><code class="highlighter-rouge">Center</code></a> widget 和其子组件 
<a href="https://docs.flutter.io/flutter/widgets/Text-class.html"><code class="highlighter-rouge">Text</code></a> widget。框架强制使 root widget 覆盖全屏，这就意味着 “Hello,word” 呈现在屏幕中央，此时可以设置字符串的布局。接下来我们将会为你演示，使用 MaterialApp widget。</p>

<p>在编写应用程序时，当创建新的 widgets，通常是 
<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget-class.html"><code class="highlighter-rouge">StatelessWidget</code></a>
或
<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html"><code class="highlighter-rouge">StatefulWidget</code></a> 的子类，具体要继承那一个，取决于你是否要管理此 widget 所有 state。
<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget/build.html"><code class="highlighter-rouge">build</code></a>
函数是 widgets 主要入口函数 
，可以在此函数里创建其他的 lower-level widgets。框架将会依次构建这些 widgets，直到最底层的 
<a href="https://docs.flutter.io/flutter/rendering/RenderObject-class.html"><code class="highlighter-rouge">RenderObject</code></a> 之下，然后计算机进行计算相关的图形并渲染出。</p>

<h2 id="basic-widgets">Basic widgets</h2>

<p><em>主要相关文章：<a href="https://flutter.io/widgets/layout">Widgets Overview - Layout Models</a></em></p>

<p>Flutter 自带有一套强大的 Basic widgets，其中以下是经常用的：</p>

<ul>
  <li>
    <p><a href="https://docs.flutter.io/flutter/widgets/Text-class.html"><code class="highlighter-rouge">Text</code></a>：
<a href="https://docs.flutter.io/flutter/widgets/Text-class.html"><code class="highlighter-rouge">Text</code></a> widget
可以在你的应用中创建一个可自定义风格的文本框。</p>
  </li>
  <li>
    <p><a href="https://docs.flutter.io/flutter/widgets/Row-class.html"><code class="highlighter-rouge">Row</code></a>,
<a href="https://docs.flutter.io/flutter/widgets/Column-class.html"><code class="highlighter-rouge">Column</code></a>：
这两个 widgets 使你无论是在水平(<a href="https://docs.flutter.io/flutter/widgets/Row-class.html"><code class="highlighter-rouge">Row</code></a>) 还是在垂直位置
(<a href="https://docs.flutter.io/flutter/widgets/Column-class.html"><code class="highlighter-rouge">Column</code></a>)
都可以创建出灵活的布局，它是基于 flexbox layout model 来设计的。</p>
  </li>
  <li>
    <p><a href="https://docs.flutter.io/flutter/widgets/Stack-class.html"><code class="highlighter-rouge">Stack</code></a>：你可以使用 
<a href="https://docs.flutter.io/flutter/widgets/Stack-class.html"><code class="highlighter-rouge">Stack</code></a> widget 来绘制需要重叠的 widget、元素，而不是安照线性方向（垂直或者水平）来布局 widget、元素。你可以在
<a href="https://docs.flutter.io/flutter/widgets/Stack-class.html"><code class="highlighter-rouge">Stack</code></a> 上使用 
<a href="https://docs.flutter.io/flutter/widgets/Positioned-class.html"><code class="highlighter-rouge">Positioned</code></a>
定位相对设置其子元素上下左右的参数。Stacks 基于网页 positioning layout model。</p>
  </li>
  <li>
    <p><a href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="highlighter-rouge">Container</code></a>：
<a href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="highlighter-rouge">Container</code></a> 
可以创建出简单的矩形元素视图。也可当做 
<a href="https://docs.flutter.io/flutter/painting/BoxDecoration-class.html"><code class="highlighter-rouge">BoxDecoration</code></a> 自定义风格的容器，例如：背景，边框，阴影。
<a href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="highlighter-rouge">Container</code></a> 可以设置 margin、padding 甚至设置任意大小尺寸。 另外 
<a href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="highlighter-rouge">Container</code></a> 可以利用矩阵在三维空间中编辑。</p>
  </li>
</ul>

<p>以下是一些简单的 widgets，它们结合了以上和其他 widgets：</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="s">'package:flutter/material.dart'</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">MyAppBar</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="n">MyAppBar</span><span class="o">({</span><span class="k">this</span><span class="o">.</span><span class="na">title</span><span class="o">});</span>

  <span class="c1">// Fields in a Widget subclass are always marked "final".</span>

  <span class="kd">final</span> <span class="n">Widget</span> <span class="n">title</span><span class="o">;</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Container</span><span class="o">(</span>
      <span class="nl">height:</span> <span class="mf">56.0</span><span class="o">,</span> <span class="c1">// in logical pixels</span>
      <span class="nl">padding:</span> <span class="kd">const</span> <span class="n">EdgeInsets</span><span class="o">.</span><span class="na">symmetric</span><span class="o">(</span><span class="nl">horizontal:</span> <span class="mf">8.0</span><span class="o">),</span>
      <span class="nl">decoration:</span> <span class="k">new</span> <span class="n">BoxDecoration</span><span class="o">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="o">.</span><span class="na">blue</span><span class="o">[</span><span class="mi">500</span><span class="o">]),</span>
      <span class="c1">// Row is a horizontal, linear layout.</span>
      <span class="nl">child:</span> <span class="k">new</span> <span class="n">Row</span><span class="o">(</span>
        <span class="c1">// &lt;Widget&gt; is the type of items in the list.</span>
        <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;[</span>
          <span class="k">new</span> <span class="n">IconButton</span><span class="o">(</span>
            <span class="nl">icon:</span> <span class="k">new</span> <span class="n">Icon</span><span class="o">(</span><span class="n">Icons</span><span class="o">.</span><span class="na">menu</span><span class="o">),</span>
            <span class="nl">tooltip:</span> <span class="s">'Navigation menu'</span><span class="o">,</span>
            <span class="nl">onPressed:</span> <span class="kc">null</span><span class="o">,</span> <span class="c1">// null disables the button</span>
          <span class="o">),</span>
          <span class="c1">// Expanded expands its child to fill the available space.</span>
          <span class="k">new</span> <span class="n">Expanded</span><span class="o">(</span>
            <span class="nl">child:</span> <span class="n">title</span><span class="o">,</span>
          <span class="o">),</span>
          <span class="k">new</span> <span class="n">IconButton</span><span class="o">(</span>
            <span class="nl">icon:</span> <span class="k">new</span> <span class="n">Icon</span><span class="o">(</span><span class="n">Icons</span><span class="o">.</span><span class="na">search</span><span class="o">),</span>
            <span class="nl">tooltip:</span> <span class="s">'Search'</span><span class="o">,</span>
            <span class="nl">onPressed:</span> <span class="kc">null</span><span class="o">,</span>
          <span class="o">),</span>
        <span class="o">],</span>
      <span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyScaffold</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Material is a conceptual piece of paper on which the UI appears.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Material</span><span class="o">(</span>
      <span class="c1">// Column is a vertical, linear layout.</span>
      <span class="nl">child:</span> <span class="k">new</span> <span class="n">Column</span><span class="o">(</span>
        <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;[</span>
          <span class="k">new</span> <span class="n">MyAppBar</span><span class="o">(</span>
            <span class="nl">title:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span>
              <span class="s">'Example title'</span><span class="o">,</span>
              <span class="nl">style:</span> <span class="n">Theme</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">primaryTextTheme</span><span class="o">.</span><span class="na">title</span><span class="o">,</span>
            <span class="o">),</span>
          <span class="o">),</span>
          <span class="k">new</span> <span class="n">Expanded</span><span class="o">(</span>
            <span class="nl">child:</span> <span class="k">new</span> <span class="n">Center</span><span class="o">(</span>
              <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Hello, world!'</span><span class="o">),</span>
            <span class="o">),</span>
          <span class="o">),</span>
        <span class="o">],</span>
      <span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">runApp</span><span class="o">(</span><span class="k">new</span> <span class="n">MaterialApp</span><span class="o">(</span>
    <span class="nl">title:</span> <span class="s">'My app'</span><span class="o">,</span> <span class="c1">// used by the OS task switcher</span>
    <span class="nl">home:</span> <span class="k">new</span> <span class="n">MyScaffold</span><span class="o">(),</span>
  <span class="o">));</span>
<span class="o">}</span>
</code></pre>
</div>
<p>请检查 <code class="highlighter-rouge">flutter</code> 文件下 <code class="highlighter-rouge">pubspec.yaml</code> 文件中 <code class="highlighter-rouge">uses-material-design: true</code>，以允许使用默认 <a href="https://design.google.com/icons/">Material icons</a></p>

<div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">name</span><span class="pi">:</span> <span class="s">my_app</span>
<span class="s">flutter</span><span class="pi">:</span>
  <span class="s">uses-material-design</span><span class="pi">:</span> <span class="s">true</span>
</code></pre>
</div>

<p>许多 widgets 在 
<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="highlighter-rouge">MaterialApp</code></a> 中呈现，是为了继承它的主题相关参数以统一设计风格。所以我们使用 
<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="highlighter-rouge">MaterialApp</code></a>。</p>

<p><code class="highlighter-rouge">MyAppBar</code> widget 里创建了一个 
<a href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="highlighter-rouge">Container</code></a> 对象，并设置参数高为56px，离屏幕左右填充8px，在 container 中，<code class="highlighter-rouge">MyAppBar</code> 使用 
<a href="https://docs.flutter.io/flutter/widgets/Row-class.html"><code class="highlighter-rouge">Row</code></a> 布局其子级界面。在中间，使用 
<a href="https://docs.flutter.io/flutter/widgets/Expanded-class.html"><code class="highlighter-rouge">Expanded</code></a> 创建 <code class="highlighter-rouge">title</code> widget，因为它可以自动填充其他子 widget 未使用的剩余空间。当然可以使用多个 
<a href="https://docs.flutter.io/flutter/widgets/Expanded-class.html"><code class="highlighter-rouge">Expanded</code></a> 对象，并且可以使用 
<a href="https://docs.flutter.io/flutter/widgets/Expanded-class.html#flex"><code class="highlighter-rouge">flex</code></a> 参数来设置可用空间的比例。</p>

<p><code class="highlighter-rouge">MyScaffold</code> widget 布局其子 widgets 使其垂直排列。在顶部，初始化了一个 <code class="highlighter-rouge">MyAppBar</code>，其标题是 
<a href="https://docs.flutter.io/flutter/widgets/Text-class.html"><code class="highlighter-rouge">Text</code></a> widget。通常我们可以在一个 widget 中，去引用其他的 widget 并作为参数，这样会提高组件的复用性。最后使用 
<a href="https://docs.flutter.io/flutter/widgets/Expanded-class.html"><code class="highlighter-rouge">Expanded</code></a> 的 <code class="highlighter-rouge">MyScaffold</code> widget 将剩下的空间全部填充。</p>

<h2 id="使用-material-components">使用 Material Components</h2>

<p><em>主要相关文章：<a href="https://flutter.io/widgets/material">Widgets Overview - Material Components</a></em></p>

<p>Flutter 提供了许多 widgets，并可帮助你构建遵循 Material Design 的应用程序。一个 Material 应用程序往往开始于 
<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="highlighter-rouge">MaterialApp</code></a>
widget，其中包括一些其他有用的 widgets。比如 
<a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html"><code class="highlighter-rouge">Navigator</code></a>，他管理一些以字符串为标识的 widgets，也可以称为”路由”，它可以帮你管理应用程序界面，使之不同的界面直接跳转平稳可控。当然你也可以不使用 
<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="highlighter-rouge">MaterialApp</code></a>，不过其依然是一个不错的选择。</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="s">'package:flutter/material.dart'</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">runApp</span><span class="o">(</span><span class="k">new</span> <span class="n">MaterialApp</span><span class="o">(</span>
    <span class="nl">title:</span> <span class="s">'Flutter Tutorial'</span><span class="o">,</span>
    <span class="nl">home:</span> <span class="k">new</span> <span class="n">TutorialHome</span><span class="o">(),</span>
  <span class="o">));</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">TutorialHome</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Scaffold is a layout for the major Material Components.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Scaffold</span><span class="o">(</span>
      <span class="nl">appBar:</span> <span class="k">new</span> <span class="n">AppBar</span><span class="o">(</span>
        <span class="nl">leading:</span> <span class="k">new</span> <span class="n">IconButton</span><span class="o">(</span>
          <span class="nl">icon:</span> <span class="k">new</span> <span class="n">Icon</span><span class="o">(</span><span class="n">Icons</span><span class="o">.</span><span class="na">menu</span><span class="o">),</span>
          <span class="nl">tooltip:</span> <span class="s">'Navigation menu'</span><span class="o">,</span>
          <span class="nl">onPressed:</span> <span class="kc">null</span><span class="o">,</span>
        <span class="o">),</span>
        <span class="nl">title:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Example title'</span><span class="o">),</span>
        <span class="nl">actions:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;[</span>
          <span class="k">new</span> <span class="n">IconButton</span><span class="o">(</span>
            <span class="nl">icon:</span> <span class="k">new</span> <span class="n">Icon</span><span class="o">(</span><span class="n">Icons</span><span class="o">.</span><span class="na">search</span><span class="o">),</span>
            <span class="nl">tooltip:</span> <span class="s">'Search'</span><span class="o">,</span>
            <span class="nl">onPressed:</span> <span class="kc">null</span><span class="o">,</span>
          <span class="o">),</span>
        <span class="o">],</span>
      <span class="o">),</span>
      <span class="c1">// body is the majority of the screen.</span>
      <span class="nl">body:</span> <span class="k">new</span> <span class="n">Center</span><span class="o">(</span>
        <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Hello, world!'</span><span class="o">),</span>
      <span class="o">),</span>
      <span class="nl">floatingActionButton:</span> <span class="k">new</span> <span class="n">FloatingActionButton</span><span class="o">(</span>
        <span class="nl">tooltip:</span> <span class="s">'Add'</span><span class="o">,</span> <span class="c1">// used by assistive technologies</span>
        <span class="nl">child:</span> <span class="k">new</span> <span class="n">Icon</span><span class="o">(</span><span class="n">Icons</span><span class="o">.</span><span class="na">add</span><span class="o">),</span>
        <span class="nl">onPressed:</span> <span class="kc">null</span><span class="o">,</span>
      <span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>现在，我们已经把原来的 <code class="highlighter-rouge">MyAppBar</code> 和 <code class="highlighter-rouge">MyScaffold</code> 分别替换为 
<a href="https://docs.flutter.io/flutter/material/AppBar-class.html"><code class="highlighter-rouge">AppBar</code></a> 和 
<a href="https://docs.flutter.io/flutter/material/Scaffold-class.html"><code class="highlighter-rouge">Scaffold</code></a>，它们都来自 <code class="highlighter-rouge">material.dart</code>，此时我们的应用程序使用了更多的 Material 元素。例如，应用栏的阴影，标题文本的样式都自动继承于 
<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="highlighter-rouge">MaterialApp</code></a> 里的相关参数。我们额外也添加了一个浮动的按钮，以便你进行参考。</p>

<p>注意，这里我们再次将其他 widgets 作为其他 widgets 的参数。
<a href="https://docs.flutter.io/flutter/material/Scaffold-class.html"><code class="highlighter-rouge">Scaffold</code></a> widget 里有许多参数都是 widgets，并且这些都通过 <code class="highlighter-rouge">Scaffold</code> 进行排版显示。同样，
<a href="https://docs.flutter.io/flutter/material/AppBar-class.html"><code class="highlighter-rouge">AppBar</code></a>
widget 里面 
<a href="https://docs.flutter.io/flutter/material/AppBar-class.html#leading"><code class="highlighter-rouge">leading</code></a>
、
<a href="https://docs.flutter.io/flutter/material/AppBar-class.html#actions"><code class="highlighter-rouge">actions</code></a>
和
<a href="https://docs.flutter.io/flutter/material/AppBar-class.html#title"><code class="highlighter-rouge">title</code></a> 参数都是 widgets。整个框架大量的使用此设计模式，所以当你去设计自己的 widgets 时可以参考下。</p>

<h2 id="手势的处理">手势的处理</h2>

<p><em>主要相关文章：<a href="https://flutter.io/gestures/">Gestures in Flutter</a></em></p>

<p>通常应用程序会和用户做一些手势交互。所以，程序首先就要去检测用户的各种手势输入。接下来，让我们通过创建一个简单的按钮来了解它的工作原理：</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyButton</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">GestureDetector</span><span class="o">(</span>
      <span class="nl">onTap:</span> <span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">'MyButton was tapped!'</span><span class="o">);</span>
      <span class="o">},</span>
      <span class="nl">child:</span> <span class="k">new</span> <span class="n">Container</span><span class="o">(</span>
        <span class="nl">height:</span> <span class="mf">36.0</span><span class="o">,</span>
        <span class="nl">padding:</span> <span class="kd">const</span> <span class="n">EdgeInsets</span><span class="o">.</span><span class="na">all</span><span class="o">(</span><span class="mf">8.0</span><span class="o">),</span>
        <span class="nl">margin:</span> <span class="kd">const</span> <span class="n">EdgeInsets</span><span class="o">.</span><span class="na">symmetric</span><span class="o">(</span><span class="nl">horizontal:</span> <span class="mf">8.0</span><span class="o">),</span>
        <span class="nl">decoration:</span> <span class="k">new</span> <span class="n">BoxDecoration</span><span class="o">(</span>
          <span class="nl">borderRadius:</span> <span class="k">new</span> <span class="n">BorderRadius</span><span class="o">.</span><span class="na">circular</span><span class="o">(</span><span class="mf">5.0</span><span class="o">),</span>
          <span class="nl">color:</span> <span class="n">Colors</span><span class="o">.</span><span class="na">lightGreen</span><span class="o">[</span><span class="mi">500</span><span class="o">],</span>
        <span class="o">),</span>
        <span class="nl">child:</span> <span class="k">new</span> <span class="n">Center</span><span class="o">(</span>
          <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Engage'</span><span class="o">),</span>
        <span class="o">),</span>
      <span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p><a href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html"><code class="highlighter-rouge">GestureDetector</code></a> 只是用来检测用户手势动作，没有显示效果，所以你看不到任何界面在程序中。当用户点击 
<a href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="highlighter-rouge">Container</code></a>，
<a href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html"><code class="highlighter-rouge">GestureDetector</code></a> 会调用它的 
<a href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html#onTap"><code class="highlighter-rouge">onTap</code></a> 回调，此时，会执行相关代码，打印消息到控制台。你可以使用 
<a href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html"><code class="highlighter-rouge">GestureDetector</code></a> 来检测各种输入手势，包括点击，拖动和缩放。</p>

<p>许多 widgets 使用 
<a href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html"><code class="highlighter-rouge">GestureDetector</code></a> 为其提供手势回调，当然你也可以不去实现其回调。例如，
<a href="https://docs.flutter.io/flutter/material/IconButton-class.html"><code class="highlighter-rouge">IconButton</code></a>,
<a href="https://docs.flutter.io/flutter/material/RaisedButton-class.html"><code class="highlighter-rouge">RaisedButton</code></a>,
和 
<a href="https://docs.flutter.io/flutter/material/FloatingActionButton-class.html"><code class="highlighter-rouge">FloatingActionButton</code></a> 有 
<a href="https://docs.flutter.io/flutter/material/RaisedButton-class.html#onPressed"><code class="highlighter-rouge">onPressed</code></a> 回调方法，你可以不用去实现 
<a href="https://docs.flutter.io/flutter/widgets/GestureDetector-class.html"><code class="highlighter-rouge">GestureDetector</code></a> 里的回调方法。</p>

<h2 id="更改-widgets-显示状态">更改 widgets 显示状态</h2>

<p><em>主要相关文章： <a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html"><code class="highlighter-rouge">StatefulWidget</code></a>, <a href="https://docs.flutter.io/flutter/widgets/State/setState.html"><code class="highlighter-rouge">State.setState</code></a></em></p>

<p>到目前为止，我们只使用 stateless widgets。stateless widgets 从它们的父 widgets 接收参数，它们存储在 <a href="https://www.dartlang.org/docs/dart-up-and-running/ch02.html#final-and-const"><code class="highlighter-rouge">final</code></a> 变量中。当一个 widget 要求
<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget/build.html"><code class="highlighter-rouge">构建</code></a>时，它使用这些已存储的值为被创建的 widget 派生新的参数。</p>

<p>我们来创建一个比较复杂的例子 - 例如，对用户的交互做出有意义的响应 - 应用程序通常会自带一些 state。Flutter 使用 StatefulWidgets 来捕获某个状态更改。StatefulWidgets 是个特殊的Widgets，它知道如何生成 State objects，然后用它来保持 state。考虑这个基本的例子，我们使用前面提到 
<a href="https://docs.flutter.io/flutter/material/RaisedButton-class.html"><code class="highlighter-rouge">RaisedButton</code></a>：</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Counter</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="o">{</span>
  <span class="c1">// This class is the configuration for the state. It holds the</span>
  <span class="c1">// values (in this nothing) provided by the parent and used by the build</span>
  <span class="c1">// method of the State. Fields in a Widget subclass are always marked "final".</span>

  <span class="nd">@override</span>
  <span class="n">_CounterState</span> <span class="n">createState</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="n">_CounterState</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">_CounterState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">Counter</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">_increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">setState</span><span class="o">(()</span> <span class="o">{</span>
      <span class="c1">// This call to setState tells the Flutter framework that</span>
      <span class="c1">// something has changed in this State, which causes it to rerun</span>
      <span class="c1">// the build method below so that the display can reflect the</span>
      <span class="c1">// updated values. If we changed _counter without calling</span>
      <span class="c1">// setState(), then the build method would not be called again,</span>
      <span class="c1">// and so nothing would appear to happen.</span>
      <span class="n">_counter</span><span class="o">++;</span>
    <span class="o">});</span>
  <span class="o">}</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This method is rerun every time setState is called, for instance</span>
    <span class="c1">// as done by the _increment method above.</span>
    <span class="c1">// The Flutter framework has been optimized to make rerunning</span>
    <span class="c1">// build methods fast, so that you can just rebuild anything that</span>
    <span class="c1">// needs updating rather than having to individually change</span>
    <span class="c1">// instances of widgets.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Row</span><span class="o">(</span>
      <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;[</span>
        <span class="k">new</span> <span class="n">RaisedButton</span><span class="o">(</span>
          <span class="nl">onPressed:</span> <span class="n">_increment</span><span class="o">,</span>
          <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Increment'</span><span class="o">),</span>
        <span class="o">),</span>
        <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Count: </span><span class="si">$_counter</span><span class="s">'</span><span class="o">),</span>
      <span class="o">],</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>你可能想知道为什么我们把 StatefulWidget 和 State 分离为单独的对象。在 Flutter 中，这两种类型的对象具有着不同的生命周期。Widgets 只是用于在界面显示当前信息的临时对象。State objects 用来保存一些状态信息，会一直存在与 
<a href="https://docs.flutter.io/flutter/widgets/State/build.html"><code class="highlighter-rouge">build()</code></a> 来回调用。</p>

<p>上面的例子，用户对界面进行交互并直接在 build method 中呈现结果。在更复杂的应用程序中，每个不同层级 widgets 都会个自负责响应不同的状态及作用；例如，一个 widget 收集特定的信息（如日期或位置）最终会呈现在复杂的用户界面上，当另一个 widget 改变这些信息时，前面的 widget 会更新其状态。</p>

<p>在 Flutter 中，widget 的更改变化是通过回调方式一层一层“向上”传递，而当前状态则“向下”传递到stateless widgets。重定向这共同父级。通过下面稍微复杂的例子，我们看看具体是如何工作的：</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CounterDisplay</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="n">CounterDisplay</span><span class="o">({</span><span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">});</span>

  <span class="kd">final</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Count: </span><span class="si">$count</span><span class="s">'</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">CounterIncrementor</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="n">CounterIncrementor</span><span class="o">({</span><span class="k">this</span><span class="o">.</span><span class="na">onPressed</span><span class="o">});</span>

  <span class="kd">final</span> <span class="n">VoidCallback</span> <span class="n">onPressed</span><span class="o">;</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">RaisedButton</span><span class="o">(</span>
      <span class="nl">onPressed:</span> <span class="n">onPressed</span><span class="o">,</span>
      <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Increment'</span><span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Counter</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="o">{</span>
  <span class="nd">@override</span>
  <span class="n">_CounterState</span> <span class="n">createState</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="n">_CounterState</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">_CounterState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">Counter</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="kt">void</span> <span class="n">_increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">setState</span><span class="o">(()</span> <span class="o">{</span>
      <span class="o">++</span><span class="n">_counter</span><span class="o">;</span>
    <span class="o">});</span>
  <span class="o">}</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Row</span><span class="o">(</span><span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;[</span>
      <span class="k">new</span> <span class="n">CounterIncrementor</span><span class="o">(</span><span class="nl">onPressed:</span> <span class="n">_increment</span><span class="o">),</span>
      <span class="k">new</span> <span class="n">CounterDisplay</span><span class="o">(</span><span class="nl">count:</span> <span class="n">_counter</span><span class="o">),</span>
    <span class="o">]);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
<p>请注意看下，我们是如何创建了两个 stateless widgets，使 <em>计数显示</em> （CounterDisplay）与 <em>计数更改</em> (CounterIncrementor) 解耦。尽管功能与前面的例子一样，但是我们把一些复杂逻辑抽取出来，并进行一层封装，这样我们就能保持父级可扩展性，以及代码的整洁。</p>

<h2 id="综合实例">综合实例</h2>

<p>让我们实践一个更完整的例子，将上面介绍的概念汇集在一起​​。我们假设在开发购物应用程序，该应用程序显示待售的各种产品，并要维护购物车。让我们来开始吧， <code class="highlighter-rouge">ShoppingListItem</code>：</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="kd">const</span> <span class="n">Product</span><span class="o">({</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">});</span>
  <span class="kd">final</span> <span class="kt">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">typedef</span> <span class="kt">void</span> <span class="nf">CartChangedCallback</span><span class="p">(</span><span class="n">Product</span> <span class="n">product</span><span class="o">,</span> <span class="kt">bool</span> <span class="n">inCart</span><span class="o">);</span>

<span class="kd">class</span> <span class="nc">ShoppingListItem</span> <span class="kd">extends</span> <span class="n">StatelessWidget</span> <span class="o">{</span>
  <span class="n">ShoppingListItem</span><span class="o">({</span><span class="n">Product</span> <span class="n">product</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">inCart</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">onCartChanged</span><span class="o">})</span>
      <span class="o">:</span> <span class="n">product</span> <span class="o">=</span> <span class="n">product</span><span class="o">,</span>
        <span class="k">super</span><span class="o">(</span><span class="nl">key:</span> <span class="k">new</span> <span class="n">ObjectKey</span><span class="o">(</span><span class="n">product</span><span class="o">));</span>

  <span class="kd">final</span> <span class="n">Product</span> <span class="n">product</span><span class="o">;</span>
  <span class="kd">final</span> <span class="kt">bool</span> <span class="n">inCart</span><span class="o">;</span>
  <span class="kd">final</span> <span class="n">CartChangedCallback</span> <span class="n">onCartChanged</span><span class="o">;</span>

  <span class="n">Color</span> <span class="n">_getColor</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// The theme depends on the BuildContext because different parts of the tree</span>
    <span class="c1">// can have different themes.  The BuildContext indicates where the build is</span>
    <span class="c1">// taking place and therefore which theme to use.</span>

    <span class="k">return</span> <span class="n">inCart</span> <span class="o">?</span> <span class="n">Colors</span><span class="o">.</span><span class="na">black54</span> <span class="o">:</span> <span class="n">Theme</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">context</span><span class="o">).</span><span class="na">primaryColor</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="n">TextStyle</span> <span class="n">_getTextStyle</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">inCart</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">TextStyle</span><span class="o">(</span>
      <span class="nl">color:</span> <span class="n">Colors</span><span class="o">.</span><span class="na">black54</span><span class="o">,</span>
      <span class="nl">decoration:</span> <span class="n">TextDecoration</span><span class="o">.</span><span class="na">lineThrough</span><span class="o">,</span>
    <span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ListTile</span><span class="o">(</span>
      <span class="nl">onTap:</span> <span class="o">()</span> <span class="o">{</span>
        <span class="n">onCartChanged</span><span class="o">(</span><span class="n">product</span><span class="o">,</span> <span class="o">!</span><span class="n">inCart</span><span class="o">);</span>
      <span class="o">},</span>
      <span class="nl">leading:</span> <span class="k">new</span> <span class="n">CircleAvatar</span><span class="o">(</span>
        <span class="nl">backgroundColor:</span> <span class="n">_getColor</span><span class="o">(</span><span class="n">context</span><span class="o">),</span>
        <span class="nl">child:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">name</span><span class="o">[</span><span class="mi">0</span><span class="o">]),</span>
      <span class="o">),</span>
      <span class="nl">title:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="nl">style:</span> <span class="n">_getTextStyle</span><span class="o">(</span><span class="n">context</span><span class="o">)),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p>ShoppingListItem widget 遵循 stateless
widgets 的常见模式。它将在构造函​​数中接收到的值存储在 
<a href="https://www.dartlang.org/docs/dart-up-and-running/ch02.html#final-and-const"><code class="highlighter-rouge">final</code></a> 成员变量中，然后在 
<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget/build.html"><code class="highlighter-rouge">build</code></a> 函数中使用它 。例如，<code class="highlighter-rouge">inCart</code> 布尔值作用两个主题之间切换：一个使用当前主题的主色，另一个使用灰色。</p>

<p>当用户点击列表选项时，widget 不会直接修改 <code class="highlighter-rouge">inCart</code> 的值。相反，widget 会调用父级 <code class="highlighter-rouge">onCartChanged</code> 函数。此方式可让你在层次结构更高的 widget 中存储状态，从而使状态持续更长的时间。在极端情况下，存储在窗口 widget 上的状态将在 
<a href="https://docs.flutter.io/flutter/widgets/runApp.html"><code class="highlighter-rouge">runApp</code></a> 的整个生命周期中持续存在。</p>

<p>当父级收到 <code class="highlighter-rouge">onCartChanged</code> 回调时，父级将更新其内部状态，这将触发父级重构并使用新的 <code class="highlighter-rouge">inCart</code> 值创建一个新的 <code class="highlighter-rouge">ShoppingListItem</code> 实例。尽管父级重构并创建了新的 <code class="highlighter-rouge">ShoppingListItem</code> 实例，不过此操作是很高效的，因为该框架会将新构建的 widget 与先前构建的 widget 进行比较，并在 
<a href="https://docs.flutter.io/flutter/rendering/RenderObject-class.html"><code class="highlighter-rouge">RenderObject</code></a> 之下仅渲染不同的地方。</p>

<p>我们来看看在父 widget 存储可变状态的例子：</p>

<!--
class Product {
  const Product({this.name});
  final String name;
}

class ShoppingListItem extends StatelessWidget {
  ShoppingListItem({Product product, bool inCart, Function onCartChanged});
  @override
  Widget build(BuildContext context) => null;
}
-->
<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ShoppingList</span> <span class="kd">extends</span> <span class="n">StatefulWidget</span> <span class="o">{</span>
  <span class="n">ShoppingList</span><span class="o">({</span><span class="n">Key</span> <span class="n">key</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">products</span><span class="o">})</span> <span class="o">:</span> <span class="k">super</span><span class="o">(</span><span class="nl">key:</span> <span class="n">key</span><span class="o">);</span>

  <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">;</span>

  <span class="c1">// The framework calls createState the first time a widget appears at a given</span>
  <span class="c1">// location in the tree. If the parent rebuilds and uses the same type of</span>
  <span class="c1">// widget (with the same key), the framework will re-use the State object</span>
  <span class="c1">// instead of creating a new State object.</span>

  <span class="nd">@override</span>
  <span class="n">_ShoppingListState</span> <span class="n">createState</span><span class="o">()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="n">_ShoppingListState</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">_ShoppingListState</span> <span class="kd">extends</span> <span class="n">State</span><span class="o">&lt;</span><span class="n">ShoppingList</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">Set</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;</span> <span class="n">_shoppingCart</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">Set</span><span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;();</span>

  <span class="kt">void</span> <span class="n">_handleCartChanged</span><span class="o">(</span><span class="n">Product</span> <span class="n">product</span><span class="o">,</span> <span class="kt">bool</span> <span class="n">inCart</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setState</span><span class="o">(()</span> <span class="o">{</span>
      <span class="c1">// When user changes what is in the cart, we need to change _shoppingCart</span>
      <span class="c1">// inside a setState call to trigger a rebuild. The framework then calls</span>
      <span class="c1">// build, below, which updates the visual appearance of the app.</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">inCart</span><span class="o">)</span>
        <span class="n">_shoppingCart</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
      <span class="k">else</span>
        <span class="n">_shoppingCart</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
    <span class="o">});</span>
  <span class="o">}</span>

  <span class="nd">@override</span>
  <span class="n">Widget</span> <span class="n">build</span><span class="o">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Scaffold</span><span class="o">(</span>
      <span class="nl">appBar:</span> <span class="k">new</span> <span class="n">AppBar</span><span class="o">(</span>
        <span class="nl">title:</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">'Shopping List'</span><span class="o">),</span>
      <span class="o">),</span>
      <span class="nl">body:</span> <span class="k">new</span> <span class="n">ListView</span><span class="o">(</span>
        <span class="nl">padding:</span> <span class="k">new</span> <span class="n">EdgeInsets</span><span class="o">.</span><span class="na">symmetric</span><span class="o">(</span><span class="nl">vertical:</span> <span class="mf">8.0</span><span class="o">),</span>
        <span class="nl">children:</span> <span class="n">widget</span><span class="o">.</span><span class="na">products</span><span class="o">.</span><span class="na">map</span><span class="o">((</span><span class="n">Product</span> <span class="n">product</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="k">new</span> <span class="n">ShoppingListItem</span><span class="o">(</span>
            <span class="nl">product:</span> <span class="n">product</span><span class="o">,</span>
            <span class="nl">inCart:</span> <span class="n">_shoppingCart</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">product</span><span class="o">),</span>
            <span class="nl">onCartChanged:</span> <span class="n">_handleCartChanged</span><span class="o">,</span>
          <span class="o">);</span>
        <span class="o">}).</span><span class="na">toList</span><span class="o">(),</span>
      <span class="o">),</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">runApp</span><span class="o">(</span><span class="k">new</span> <span class="n">MaterialApp</span><span class="o">(</span>
    <span class="nl">title:</span> <span class="s">'Shopping App'</span><span class="o">,</span>
    <span class="nl">home:</span> <span class="k">new</span> <span class="n">ShoppingList</span><span class="o">(</span>
      <span class="nl">products:</span> <span class="o">&lt;</span><span class="n">Product</span><span class="o">&gt;[</span>
        <span class="k">new</span> <span class="n">Product</span><span class="o">(</span><span class="nl">name:</span> <span class="s">'Eggs'</span><span class="o">),</span>
        <span class="k">new</span> <span class="n">Product</span><span class="o">(</span><span class="nl">name:</span> <span class="s">'Flour'</span><span class="o">),</span>
        <span class="k">new</span> <span class="n">Product</span><span class="o">(</span><span class="nl">name:</span> <span class="s">'Chocolate chips'</span><span class="o">),</span>
      <span class="o">],</span>
    <span class="o">),</span>
  <span class="o">));</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">ShoppingList</code> 类扩展于 
<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html"><code class="highlighter-rouge">StatefulWidget</code></a>，使之可以存储一些可变的状态。当 <code class="highlighter-rouge">ShoppingList</code> 首次创建时，框架会调用 
<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html#createState"><code class="highlighter-rouge">createState</code></a> 函数创建一个新的实例 <code class="highlighter-rouge">_ShoppingListState</code> 来关联此时的位置（请注意，我们通常命名 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html"><code class="highlighter-rouge">State</code></a>的子类为带有下划线的，来表示它们是私有的。）当此 widget 的父级被重构时，父级将会创建一个新的 <code class="highlighter-rouge">ShoppingList</code> 实例，框架会重新关联使用 <code class="highlighter-rouge">_ShoppingListState</code> 尽管之前已经调用了 
<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html#createState"><code class="highlighter-rouge">createState</code></a>，但是此时还会再次调用。</p>

<p>可以通过 <code class="highlighter-rouge">_ShoppingListState</code> 使用 <code class="highlighter-rouge">ShoppingList</code> 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#widget"><code class="highlighter-rouge">widget</code></a> 的属性来获取它的属性。如果父级重建并创建新的 <code class="highlighter-rouge">ShoppingList</code>，那么 <code class="highlighter-rouge">_ShoppingListState</code> 也将用新的 widget 的属性重建。如果希望 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#widget"><code class="highlighter-rouge">widget</code></a> 属性更改时收到通知，则可以复写 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#didUpdateWidget"><code class="highlighter-rouge">didUpdateWidget</code></a> 函数。以便 <code class="highlighter-rouge">oldWidget</code> 将之前的 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#widget"><code class="highlighter-rouge">widget</code></a> 与现在的进行比较。</p>

<p>当 <code class="highlighter-rouge">onCartChanged</code> 回调被调用时， <code class="highlighter-rouge">_ShoppingListState</code> 在 <code class="highlighter-rouge">_shoppingCart</code> 里进行添加删除产品，从而改变了状态。调用 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#setState"><code class="highlighter-rouge">setState</code></a> 方法会通知框架改变器状态。当调用 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#setState"><code class="highlighter-rouge">setState</code></a> 方法时会标记修改的 widget 并计划在下次应用程序需要更新用户界面时重新构建它。如果你修改 widget 状态时忘记调用
[<code class="highlighter-rouge">setState</code>] (https://docs.flutter.io/flutter/widgets/State-class.html#setState) 方法，框架就不知道此 widget 是被修改过的，并不会调用此 widget 的 
<a href="https://docs.flutter.io/flutter/widgets/StatelessWidget/build.html"><code class="highlighter-rouge">build</code></a> 函数，最终会导致不会更新此状态，界面也不会发生什么变化。</p>

<p>通过以上这种方式管理状态，你不需要编写用于创建和更新子部件的单独代码。相反，你只需实现可以处理这两种情况的 build 函数。</p>

<h2 id="widget-的生命周期">widget 的生命周期</h2>

<p><em>主要文章：<a href="https://docs.flutter.io/flutter/widgets/State-class.html"><code class="highlighter-rouge">State</code></a></em></p>

<p>在 StatefulWidget 调用 
<a href="https://docs.flutter.io/flutter/widgets/StatefulWidget-class.html#createState"><code class="highlighter-rouge">createState</code></a> 后，框架会插入新的 state object 在节点树中，然后在调用
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#initState"><code class="highlighter-rouge">initState</code></a> 在此对象上。子类 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html"><code class="highlighter-rouge">State</code></a> 
可以复写 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#initState"><code class="highlighter-rouge">initState</code></a> 并且只会调用一次。例如，你可以复写 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#initState"><code class="highlighter-rouge">initState</code></a> 以配置动画或订阅平台服务。
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#initState"><code class="highlighter-rouge">initState</code></a> 实现之前，需要先调用 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#initState"><code class="highlighter-rouge">super.initState</code></a>。</p>

<p>当一个 state object 不再需要时，框架调用 state object 的 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#dispose"><code class="highlighter-rouge">dispose</code></a> 函数时，你可以复写该 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#dispose"><code class="highlighter-rouge">dispose</code></a> 函数来执行清理工作。例如，你可以复写 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#dispose"><code class="highlighter-rouge">dispose</code></a> 来取消定时器或取消平台订阅服务。当然调用 
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#dispose"><code class="highlighter-rouge">dispose</code></a> 之前，要先调用
<a href="https://docs.flutter.io/flutter/widgets/State-class.html#dispose"><code class="highlighter-rouge">super.dispose</code></a>。</p>

<h2 id="keys">Keys</h2>
<p><em>主要相关文章：<a href="https://docs.flutter.io/flutter/foundation/Key-class.html"><code class="highlighter-rouge">Key</code></a></em></p>

<p>你可以使用 keys 来找到 widgets 并控制它，框架将会通过 keys 来匹配已经构建好的相应 widgets。默认情况下，框架会根据 
<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html#runtimeType"><code class="highlighter-rouge">runtimeType</code></a> 以及显示顺序来匹配当前构建和以前构建中的 widgets。通过 keys，框架需要两个 widgets 有相同的 
<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html#key"><code class="highlighter-rouge">key</code></a> 以及 
<a href="https://docs.flutter.io/flutter/widgets/Widget-class.html#runtimeType"><code class="highlighter-rouge">runtimeType</code></a>。</p>

<p>当有构建许多相同类型的 widgets 时，keys 属性是还是非常有用的。例如，<code class="highlighter-rouge">ShoppingList</code> widget 构建可以填充其可见区域的 <code class="highlighter-rouge">ShoppingListItem</code> 实例:</p>

<ul>
  <li>
    <p>如果没有 keys，当前构建中的第一个 item 将始终与前一个构建中的第一个 item 同步，即使在逻辑上，列表中的第一个 item 已经滚动出了屏幕。</p>
  </li>
  <li>
    <p>通过列表中的每个 item 的 “semantic” keys，以使整个列表效果正常，因为框架将通过 keys 同步 item 并因此具有相似（或相同）的显示效果。此外，使用语义来同步列表中的子项意味着 Stateful widget 中的 State 将和具有相同语义的 Stateful Widget 进行匹配而不是跟列表中相同位置的 Stateful Widget 进行匹配。</p>
  </li>
</ul>

<h2 id="全局-keys">全局 Keys</h2>

<p><em>主要相关文章：<a href="https://docs.flutter.io/flutter/widgets/GlobalKey-class.html"><code class="highlighter-rouge">GlobalKey</code></a></em></p>

<p>你可以使用全局 keys 标识唯一子窗口 widgets。全局 keys 在整个界面 widgets 层次结构中必须是唯一的，这与局部 keys 不同，后者只需要在同级中有唯一性。由于它们是全局唯一的，因此可以使用全局 keys 来检索与界面 widgets 关联的状态。</p>


</article>

          </div>
        </div>

        

      </div> <!-- /.row -->
    </div> <!-- /.container -->

    <footer class="site-footer">
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-12">
        <div class="logo">
          <img src="/images/flutter-mark-square-100.png" alt="Flutter Logo" width="100" height="100">
        </div>
        <p class="site-footer__link-list">
          <a href="https://groups.google.com/forum/#!forum/flutter-dev">flutter-dev@</a> &bull;
          <a href="https://twitter.com/flutterio">twitter</a> &bull;
          <a href="https://github.com/flutter/">github</a> &bull;
          <a href="/tos">terms</a> &bull;
          <a href="https://www.google.com/intl/en/policies/privacy/">privacy</a> &bull;
          <a href="https://github.com/orgs/flutter-dev/teams/flutter/">翻译组</a>
        </p>

        <p class="licenses">
          除非另有说明，否则本作品根据
          <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可证</a>进行许可，代码示例已根据 BSD 许可证进行许可。
        </p>
      </div>
    </div>
  </div>
</footer>

    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="/js/sidebar_toggle.js"></script>
    <script src="/js/customscripts.js"></script>
    <script src="/js/prism.js"></script>
    <script src="/js/tabs.js"></script>
    <script src="/js/archive.js"></script>
    
    <script async="" defer="" src="//survey.g.doubleclick.net/async_survey?site=at3ul57xpub2vk3oxt2ytw365i"></script>
  </body>
</html>
