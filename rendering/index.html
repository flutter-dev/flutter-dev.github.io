<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>在 Flutter 中渲染  - Flutter </title>
  <link rel="shortcut icon" href="/images/favicon.png">

  <meta name="description" content="">
  <meta name="keywords" content=" ">

  <link rel="stylesheet" href="/css/lavish-bootstrap.css">
  <link rel="stylesheet" href="/css/main.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Extended" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro%7CRoboto:500,400italic,300,400" rel="stylesheet">
  
  <link rel="canonical" href="http://localhost:4000/rendering/">

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67589403-1', 'auto');
    ga('send', 'pageview');
  </script>

  <meta name="google-site-verification" content="HFqxhSbf9YA_0rBglNLzDiWnrHiK_w4cqDh2YD2GEY4" />
</head>


  <body class="">

    <div id="overlay-under-drawer"><!-- for the drawer on narrow screens --></div>

    <header class="site-header">
  <div class="container-fluid header-contents">
    <div class="row">
      <div class="col-md-12">
        <i class="fa fa-bars" id="sidebar-toggle-button" aria-hidden="true" style="display:none"></i>
        <img src="/images/flutter-mark-square-100.png" alt="Flutter Logo" width="40" height="40" style="vertical-align:middle">

        <a class="site-title" href="/">Flutter</a>

        <nav class="site-nav">
          <a href="#" class="menu-icon">
            <i class="material-icons-extended">more_vert</i>
          </a>
          <div class="trigger">
            <a class="page-link" href="/docs/">文档</a>
            <a class="page-link" href="https://github.com/flutter/flutter">GitHub</a>
            <a class="page-link" href="https://pub.dartlang.org/flutter">库</a>
            <a class="page-link" href="/support/">支持</a>
            <a class="page-link" href="http://flutter-dev.cn">论坛</a>
            <form action="/search/" class="nav-searchbox" id="cse-search-box" style="display: inline">
              <input type="hidden" name="cx" value="007067728241810524621:gm6vraqlc8c">
              <input type="hidden" name="ie" value="UTF-8">
              <input type="hidden" name="hl" value="en">
              <input type="search" name="q" id="q" autocomplete="off" placeholder="搜索">
            </form>
          </div>
        </nav>
      </div>
    </div> <!-- /.row -->
  </div> <!-- /.container -->
</header>


    <!-- Page Content -->
    <div class="container-fluid contents">
      <!-- Content Row -->
      <div class="row">

        <!-- Sidebar Column -->
        <div id="side-nav-container" class="col-sm-3">
          <ul id="mysidebar" class="nav">

  <li class="sidebar-title">入门</li>

    <ul class="sidebar-items">
      <li><a href="/get-started/install/">1: 安装</a></li>
      <li><a href="/get-started/editor/">2: 配置编辑器</a></li>
      <li><a href="/get-started/test-drive/">3: Flutter 初体验</a></li>
      <li><a href="/get-started/codelab/">4: 编写第一个 Flutter 应用</a></li>
      <li><a href="/get-started/learn-more/">5: 学习更多</a></li>
    </ul>

  <li class="sidebar-title">构建 UI</li>

    <ul class="sidebar-items">
      <li><a href="/widgets-intro/">框架预览</a></li>
      <li><a href="/widgets/">Widget 目录</a></li>
      <li><a href="/cookbook/">小案例</a></li>
      <li><a href="/catalog/samples/">示例目录</a></li>
      <li><a href="/codelabs">Codelab</a></li>
      <li><a href="/tutorials/layout/">构建布局 - 教程</a></li>
      <li><a href="/tutorials/interactive/">添加交互 - 教程</a></li>
      <li><a href="/web-analogs/"> Web 开发者参考</a></li>
      <li><a href="/flutter-for-android/">Android 开发者参考</a></li>
      <li><a href="/flutter-for-ios/">iOS 开发者参考</a></li>
      <li><a href="/flutter-for-react-native/">React Native 开发者参考</a></li>
      <li><a href="/gestures/">手势</a></li>
      <li><a href="/animations/">动画</a></li>
      <li><a href="/layout/">框约束</a></li>
      <li><a href="/assets-and-images/">资源与图像</a></li>
      <li><a href="/tutorials/internationalization">国际化</a></li>
      <li><a href="/accessibility">无障碍</a></li>
    </ul>

  <li class="sidebar-title">使用设备与 SDK 中的 API</li>

    <ul class="sidebar-items">
      <li><a href="/using-packages/">使用扩展包</a></li>
      <li><a href="/developing-packages/">开发扩展包</a></li>
      <li><a href="/platform-channels/">平台特定代码</a></li>
      <li><a href="/json/">JSON 和序列化</a></li>
      
    </ul>

  <li class="sidebar-title">开发与工具</li>

    <ul class="sidebar-items">
      <li><a href="/using-ide/">Flutter IDE 的使用</a></li>
      <li><a href="/hot-reload/">热重载的使用</a></li>
      <li><a href="/testing/">应用测试</a></li>
      <li><a href="/debugging/">应用调试</a></li>
      <li><a href="/ui-performance/">性能分析</a></li>
      <li><a href="/inspector/">用户界面检查</a></li>
      <li><a href="/android-release/">编译正式版的 Android 应用</a></li>
      <li><a href="/ios-release/">编译正式版的 iOS 应用</a></li>
      <li><a href="/fastlane-cd/">使用 Fastlane 持续部署</a></li>
      <li><a href="/upgrading/">升级 Flutter</a></li>
      <li><a href="/formatting/"> 格式化代码</a></li>
    </ul>

  <li class="sidebar-title">更多细节</li>

    <ul class="sidebar-items">
      <li><a href="/faq/">FAQ</a></li>
      <li><a href="/technical-overview">技术一览</a></li>
      <li><a href="https://docs.google.com/presentation/d/1B3p0kP6NV_XMOimRV09Ms75ymIjU5gr6GGIX74Om_DE/edit?usp=sharing">神奇的 Flutter - 幻灯片</a></li>
      <li><a href="https://docs.google.com/presentation/d/1cw7A4HbvM_Abv320rVgPVGiUP2msVs7tfGbkgdrTy0I/edit?usp=sharing">架构图</a></li>
      <li><a href="https://www.bilibili.com/video/av14430321/">Flutter 框架层设计 <i class="fa fa-video-camera" aria-hidden="true"></i></a></li>
      <li><a href="https://www.bilibili.com/video/av6269773/">Flutter 的渲染管线 <i class="fa fa-video-camera" aria-hidden="true"></i></a></li>
    </ul>

</ul>

        </div>

        
        

        <!-- Content Column -->
        <div class="col-sm-9 main-contents">
          <div class="main-contents-body">
            <article class="post-content">
  
  
  <header class="post-header">
      <div class="btn-group contribute" role="group">
         <a href="https://github.com/flutter/website/blob/master/rendering.md" class="btn btn-sm">
            <i class="fa fa-pencil"></i> Edit Source
         </a>
         <a href="https://github.com/flutter/flutter/issues/new?title=Issue from website page 在 Flutter 中渲染&body=From URL: http://localhost:4000/rendering/&labels=dev: docs - website" class="btn btn-sm">
            <i class="fa fa-github"></i> File Issue
        </a>
     </div>
   <div>
    <h1 class="post-title">在 Flutter 中渲染 </h1>
   </div>

  </header>
  

  <ul id="markdown-toc">
  <li><a href="#介绍" id="markdown-toc-介绍">介绍</a>    <ul>
      <li><a href="#基本模型" id="markdown-toc-基本模型">基本模型</a></li>
      <li><a href="#父数据" id="markdown-toc-父数据">父数据</a></li>
      <li><a href="#盒子模型" id="markdown-toc-盒子模型">盒子模型</a>        <ul>
          <li><a href="#尺寸" id="markdown-toc-尺寸">尺寸</a></li>
          <li><a href="#edgeinsets" id="markdown-toc-edgeinsets">EdgeInsets</a></li>
          <li><a href="#boxconstraints" id="markdown-toc-boxconstraints">BoxConstraints</a></li>
        </ul>
      </li>
      <li><a href="#bespoke-models" id="markdown-toc-bespoke-models">Bespoke Models</a></li>
    </ul>
  </li>
  <li><a href="#使用所提供的子类" id="markdown-toc-使用所提供的子类">使用所提供的子类</a>    <ul>
      <li><a href="#render_boxdart" id="markdown-toc-render_boxdart">render_box.dart</a>        <ul>
          <li><a href="#renderconstrainedbox" id="markdown-toc-renderconstrainedbox">RenderConstrainedBox</a></li>
          <li><a href="#rendershrinkwrapwidth" id="markdown-toc-rendershrinkwrapwidth">RenderShrinkWrapWidth</a></li>
          <li><a href="#renderopacity" id="markdown-toc-renderopacity">RenderOpacity</a></li>
          <li><a href="#rendercolorfilter" id="markdown-toc-rendercolorfilter">RenderColorFilter</a></li>
          <li><a href="#rendercliprect" id="markdown-toc-rendercliprect">RenderClipRect</a></li>
          <li><a href="#renderclipoval" id="markdown-toc-renderclipoval">RenderClipOval</a></li>
          <li><a href="#renderpadding" id="markdown-toc-renderpadding">RenderPadding</a></li>
          <li><a href="#renderpositionedbox" id="markdown-toc-renderpositionedbox">RenderPositionedBox</a></li>
          <li><a href="#renderimage" id="markdown-toc-renderimage">RenderImage</a></li>
          <li><a href="#renderdecoratedbox" id="markdown-toc-renderdecoratedbox">RenderDecoratedBox</a></li>
          <li><a href="#rendertransform" id="markdown-toc-rendertransform">RenderTransform</a></li>
          <li><a href="#rendersizeobserver" id="markdown-toc-rendersizeobserver">RenderSizeObserver</a></li>
          <li><a href="#rendercustompaint" id="markdown-toc-rendercustompaint">RenderCustomPaint</a></li>
        </ul>
      </li>
      <li><a href="#renderblock-render_blockdart" id="markdown-toc-renderblock-render_blockdart">RenderBlock (render_block.dart)</a></li>
      <li><a href="#renderflex-render_flexdart" id="markdown-toc-renderflex-render_flexdart">RenderFlex (render_flex.dart)</a></li>
      <li><a href="#renderparagraph-render_paragraphdart" id="markdown-toc-renderparagraph-render_paragraphdart">RenderParagraph (render_paragraph.dart)</a></li>
      <li><a href="#renderstack-render_stackdart" id="markdown-toc-renderstack-render_stackdart">RenderStack (render_stack.dart)</a></li>
    </ul>
  </li>
  <li><a href="#编写新的子类" id="markdown-toc-编写新的子类">编写新的子类</a>    <ul>
      <li><a href="#renderobject的协议" id="markdown-toc-renderobject的协议">RenderObject的协议</a>        <ul>
          <li><a href="#parentdata-的协议" id="markdown-toc-parentdata-的协议">ParentData 的协议</a></li>
          <li><a href="#renderobjectwithchildmixin-的使用" id="markdown-toc-renderobjectwithchildmixin-的使用">RenderObjectWithChildMixin 的使用</a></li>
          <li><a href="#containerrenderobjectmixin和-containerparentdatamixin-的使用" id="markdown-toc-containerrenderobjectmixin和-containerparentdatamixin-的使用">ContainerRenderObjectMixin(和 ContainerParentDataMixin) 的使用</a></li>
        </ul>
      </li>
      <li><a href="#renderbox的协议" id="markdown-toc-renderbox的协议">RenderBox的协议</a>        <ul>
          <li><a href="#renderproxybox-的使用" id="markdown-toc-renderproxybox-的使用">RenderProxyBox 的使用</a></li>
        </ul>
      </li>
      <li><a href="#hit-testing-的协议" id="markdown-toc-hit-testing-的协议">Hit Testing 的协议</a></li>
    </ul>
  </li>
  <li><a href="#性能经验法则" id="markdown-toc-性能经验法则">性能经验法则</a></li>
  <li><a href="#有用的调试工具" id="markdown-toc-有用的调试工具">有用的调试工具</a></li>
</ul>

<h2 id="介绍">介绍</h2>

<p>Flutter 的渲染树 (rendering tree) 是一个低层次的布局和绘制系统，基于一颗保留着继承自 <code class="highlighter-rouge">RenderObject</code> 对象的树。大多数使用 Flutter 的开发人员不需要直接与渲染树交互，而应使用 
<a href="/widgets-intro/">widgets</a>，他们是用渲染树创建。</p>

<h3 id="基本模型">基本模型</h3>

<p><code class="highlighter-rouge">RenderObject</code> 是渲染树中每个节点的基类，它定义了基本布局模型。基本布局模型是非常普遍的，可以容纳大量的具体的布局模型并存于同一棵树中。例如，基本布局模型提交一个尺寸的固定数量甚至笛卡尔
坐标系。这样看来，一颗渲染树让在三维空间里的渲染对象与其他在二维空间里的渲染对象一起运作，例如，在一个三维空间中的立方体表面上。并且，这个二维布局可能一部分的在笛卡尔坐标计算一部分在极坐标中计算。
这些不同的模型可以在布局过程中进行交互，例如根据立方体表面上文本块的高度来该确定立方体的大小。</p>

<p>渲染树并不完全是自由运转的，基本布局模型强加一些构造在渲染树上：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">RenderObject</code> 的子类必须实现一个 <code class="highlighter-rouge">performLayout</code> 的方法把其父对象提供的 <code class="highlighter-rouge">constraints</code> 对象作为输入。
<code class="highlighter-rouge">RenderObject</code> 对这个对象的构造和不同的布局模型使用不同类型的约束的没有决定权。但是，无论他们选择什么都必须实现 <code class="highlighter-rouge">operator==</code> 函数，这样才能使得 <code class="highlighter-rouge">performLayout</code> 为两个可以 <code class="highlighter-rouge">operator ==</code> 的 <code class="highlighter-rouge">constraints</code> 对象为产生相同输出。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">performLayout</code> 的实现者们期望调用子类的 <code class="highlighter-rouge">layout</code> 方法。当调用 <code class="highlighter-rouge">layout</code> 时，<code class="highlighter-rouge">RenderObject</code> 必须用 <code class="highlighter-rouge">parentUsesSize</code> 作为参数,来声明是否它的 <code class="highlighter-rouge">performLayout</code> 函数要依赖从子类读取的信息。如果父类没有声明它要使用到子类的大小，从父到子的边缘变成一种 <em>relayout boundary</em> ，意味着子类（及其子树）的布局可能不受父类布局影响。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RenderObject</code> 的子类必须实现一个 <code class="highlighter-rouge">paint</code> 函数将一个可视化对象绘制一个到 <code class="highlighter-rouge">PaintingCanvas</code> 上。如果 <code class="highlighter-rouge">RenderObject</code> 有子类，<code class="highlighter-rouge">RenderObject</code> 就有绘制子类的责任,通过调用在 <code class="highlighter-rouge">PaintingCanvas</code> 上 <code class="highlighter-rouge">paintChild</code> 方法。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RenderObject</code> 在添加子类时必须调用 <code class="highlighter-rouge">adoptChild</code>。类似地，在删除子类时必须调用 <code class="highlighter-rouge">dropChild</code>。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RenderObject</code> 的大多数子类将实现一个 <code class="highlighter-rouge">hitTest</code> 方法，让客户端查询渲染树上的跟给定用户输入位置相交的对象。<code class="highlighter-rouge">RenderObject</code> 自身并不会强加一个特定的类型标识在 <code class="highlighter-rouge">hitTest</code> 上，但是大多数的实现者会接收一个参数类型为 <code class="highlighter-rouge">HitTestResult</code>（或者，更有可能的是 <code class="highlighter-rouge">HitTestResult</code> 的特定模型子类）以及一个描述给用户提供输入位置的对象（例如，一个在二维笛卡儿坐标系中的“点”模型）。</p>
  </li>
  <li>
    <p>最后，<code class="highlighter-rouge">RenderObject</code> 的子类可以重载默认的空实现 <code class="highlighter-rouge">handleEvent</code> 和 <code class="highlighter-rouge">rotate</code> 函数来分别响应用户的输入、屏幕旋转。</p>
  </li>
</ul>

<p>基本模型还提供了两个常见的孩子混合模型：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">RenderObjectWithChildMixin</code> 是 <code class="highlighter-rouge">RenderObject</code> 非常有用的子类，它有一个独特的孩子。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RenderObjectWithChildMixin</code> 是 <code class="highlighter-rouge">RenderObject</code> 非常有用的子类，有一个孩子列表。</p>
  </li>
</ul>

<p><code class="highlighter-rouge">RenderObject</code> 的子类不一定要使用这些模型，它可以为其特定用例自由地创建新的子类模型 。</p>

<h3 id="父数据">父数据</h3>

<p>TODO(ianh) : 描述父数据的概念。</p>

<p>当父节点发生变化时,每个 child 都会自发调用 <code class="highlighter-rouge">setupParentData()</code> 方法。但是，如果你想在一个 节点添加到父级之前设置其 <code class="highlighter-rouge">parentData</code>  成员的初始值，你可以先调用未来的父节点的 <code class="highlighter-rouge">setupParentData()</code>  方法并把未来子节点作为参数。</p>

<p>TODO(ianh) : 讨论子节点的 parentData 会把每个子节点的的配置信息给到父级。</p>

<p>如果动态更改子级 的parentData，则还必须调用父级的  markNeedsLayout()，否则新消息不会生效
直到被其他事件触发布局。</p>

<h3 id="盒子模型">盒子模型</h3>
<h4 id="尺寸">尺寸</h4>

<p>所有尺寸均以逻辑像素单位表示。字体大小也是逻辑像素单位。逻辑像素单位大约为 96 dpi，但是精确值根据硬件而不同，在这样
可优化性能和渲染质量，保持在不同的硬件像素密度下界面尺寸大致相同。</p>

<p>绘制图像时逻辑像素单元会根据合适的比例因子自动转换为设备（硬件）的像素。</p>

<p>TODO(ianh) : 您是如何在需要时获得设备像素比例的，并记录最佳实践。</p>

<h4 id="edgeinsets">EdgeInsets</h4>

<h4 id="boxconstraints">BoxConstraints</h4>

<h3 id="bespoke-models">Bespoke Models</h3>

<h2 id="使用所提供的子类">使用所提供的子类</h2>

<h3 id="render_boxdart">render_box.dart</h3>

<h4 id="renderconstrainedbox">RenderConstrainedBox</h4>

<h4 id="rendershrinkwrapwidth">RenderShrinkWrapWidth</h4>

<h4 id="renderopacity">RenderOpacity</h4>

<h4 id="rendercolorfilter">RenderColorFilter</h4>

<h4 id="rendercliprect">RenderClipRect</h4>

<h4 id="renderclipoval">RenderClipOval</h4>

<h4 id="renderpadding">RenderPadding</h4>

<h4 id="renderpositionedbox">RenderPositionedBox</h4>

<h4 id="renderimage">RenderImage</h4>

<h4 id="renderdecoratedbox">RenderDecoratedBox</h4>

<h4 id="rendertransform">RenderTransform</h4>

<h4 id="rendersizeobserver">RenderSizeObserver</h4>

<h4 id="rendercustompaint">RenderCustomPaint</h4>

<h3 id="renderblock-render_blockdart">RenderBlock (render_block.dart)</h3>

<h3 id="renderflex-render_flexdart">RenderFlex (render_flex.dart)</h3>

<h3 id="renderparagraph-render_paragraphdart">RenderParagraph (render_paragraph.dart)</h3>

<h3 id="renderstack-render_stackdart">RenderStack (render_stack.dart)</h3>

<h2 id="编写新的子类">编写新的子类</h2>

<h3 id="renderobject的协议">RenderObject的协议</h3>

<p>如果你想使用新坐标系定义一个 <code class="highlighter-rouge">RenderObject</code>，那么您应该直接从  <code class="highlighter-rouge">RenderObject</code> 继承。可以在 <code class="highlighter-rouge">RenderBox</code> 中找到这样做的示例，它在笛卡尔空间中处理矩形，在 <a href="https://github.com/flutter/flutter/blob/master/examples/layers/rendering/src/sector_layout.dart">sector_layout.dart
example</a> 示例中可以实现基于极坐标的玩具模型。 <code class="highlighter-rouge">RenderView</code> 类是另一个例子，它在内部使用来适应从系统主机到渲染框架。</p>

<p>一个 <code class="highlighter-rouge">RenderObject</code> 的子类必须满足以下协议:</p>

<ul>
  <li>
    <p>在处理子类时，必须遵循 <code class="highlighter-rouge">AbstractNode</code> 协议。使用  <code class="highlighter-rouge">RenderObjectWithChildMixin</code> 或  <code class="highlighter-rouge">ContainerRenderObjectMixin</code>  可以使这更容易。</p>
  </li>
  <li>
    <p>有关由父类管理的子类的信息，例如，通常父类布局的位置信息和配置应存储在  <code class="highlighter-rouge">parentData</code> 成员上；为此，应该定义一个 ParentData 子类，并重写 <code class="highlighter-rouge">setupParentData()</code> 方法以适当地初始化子类的父数据。</p>
  </li>
  <li>
    <p>布局约束必须用 Constraints 的子类表示。这个子类必须实现  <code class="highlighter-rouge">operator==</code>（和 <code class="highlighter-rouge">hashCode</code>）。</p>
  </li>
  <li>
    <p>每当布局需要更新时，都应该调用 <code class="highlighter-rouge">markNeedsLayout()</code> 方法。</p>
  </li>
  <li>
    <p>每当需要更新渲染而不更改布局时，应调用 <code class="highlighter-rouge">markNeedsPaint()</code> 函数。（调用 <code class="highlighter-rouge">markNeedsLayout()</code> 就意味着调用 <code class="highlighter-rouge">markNeedsPaint()</code>，所以你不需要同时调用它们。）</p>
  </li>
  <li>
    <p>子类必须重载 <code class="highlighter-rouge">performLayout()</code> 以根据 <code class="highlighter-rouge">constraints</code> 成员中给出的约束条件执行布局。每个对象都负责确定自己的尺寸;定位必须由调用了  <code class="highlighter-rouge">performLayout()</code> 的对象完成。是在孩子布局之前还是之后进行定位是由这个类决定的。</p>

    <p>TODO(ianh): sizedByParent, performResize(), rotate 的文档</p>
  </li>
  <li>
    <p>TODO(ianh): painting, hit testing, debug* 的文档</p>
  </li>
</ul>

<h4 id="parentdata-的协议">ParentData 的协议</h4>

<h4 id="renderobjectwithchildmixin-的使用">RenderObjectWithChildMixin 的使用</h4>

<h4 id="containerrenderobjectmixin和-containerparentdatamixin-的使用">ContainerRenderObjectMixin(和 ContainerParentDataMixin) 的使用</h4>

<p>这个 mixin 可以用在有孩子列表的类来管理列表。它使用 <code class="highlighter-rouge">parentData</code>  结构中的链表指针实现这个列表。</p>

<p>TODO(ianh): 这个 mixin 的文档</p>

<p>除了父类的协议，子类还必须遵循以下约束：</p>

<ul>
  <li>如果构造函数有一列的孩子，它必须调用 addAll() 添加那个列表。</li>
</ul>

<p>TODO(ianh): 说明如何使用这些孩子们。</p>

<h3 id="renderbox的协议">RenderBox的协议</h3>

<p>一个 <code class="highlighter-rouge">RenderBox</code> 子类需要实现以下协议：</p>

<ul>
  <li>
    <p>在处理孩子们时，它必须遵循 <code class="highlighter-rouge">AbstractNode</code> 协议。请注意， <code class="highlighter-rouge">RenderObjectWithChildMixin</code> 或 <code class="highlighter-rouge">ContainerRenderObjectMixin</code> 时为你服务时,你也得遵循他们的协议。</p>
  </li>
  <li>
    <p>如果有任何数据存储在其子节点上，它必须定义一个 BoxParentData 的子类并重载 setupParentData() 以给孩子的 parent data 初始化合适的数据，如下面示例。（如果子类想让它孩子们必须是什么类型，例如，  <code class="highlighter-rouge">RenderBlock</code> 希望其子级都为 <code class="highlighter-rouge">RenderBox</code> 节点，则相应地更改  <code class="highlighter-rouge">setupParentData()</code> 识别标志，以捕获该方法的误用。）</p>
  </li>
</ul>

<!-- skip -->
<div class="language-dart highlighter-rouge"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nc">FooParentData</span> <span class="kd">extends</span> <span class="n">BoxParentData</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="c1">// 在RenderFoo中</span>
  <span class="kt">void</span> <span class="n">setupParentData</span><span class="o">(</span><span class="n">RenderObject</span> <span class="n">child</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="na">parentData</span> <span class="k">is</span><span class="o">!</span> <span class="n">FooParentData</span><span class="o">)</span>
      <span class="n">child</span><span class="o">.</span><span class="na">parentData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FooParentData</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre>
</div>

<ul>
  <li>该类必须封装具有以下功能的布局算法：</li>
</ul>

<p>** 用一个 BoxConstraints 对象来描述的一系列的约束集合作为输入，以及通过类自已来决定零或多个的孩子集，并输出一个 Size（在对象自己的 <code class="highlighter-rouge">size</code> 属性中设置） ，以及每个孩子的位置（在孩子的 <code class="highlighter-rouge">parentData.position</code> 属性中设置）。</p>

<p>** 该算法可以通过以下两种方式之一来决定大小：或者完全基于给定的约束条件（即，它完全由其父级完全确定大小），或者基于以上这些约束条件和孩子们的尺寸。</p>

<p>在前一种情况下，该类必须具有返回 true 的 sizeByParent的getter，并且它必须有一个 <code class="highlighter-rouge">performResize()</code> 的方法来用这个对象的  <code class="highlighter-rouge">constraints</code> 成员去计算自身的大小。大小必须保持一致，一组给定约束结果总是相同的大小。</p>

<p>在后一种情况下，它将继承 <code class="highlighter-rouge">sizedByParent</code> 默认的 getter 方法返回 false，并且它将在下面描述的 <code class="highlighter-rouge">performLayout()</code> 函数中计算自身的大小。</p>

<p><code class="highlighter-rouge">sizedByParent</code> 优势就是纯粹的性能优化。它使得节点根据基于传入的约束只设置其大小而跳过那些在重新布局时的逻辑，更重要的是，它让布局系统将节点作为一个 <em>layout boundary</em>，从而减少当节点被标记为需要 layout 时的工作量。</p>

<ul>
  <li>
    <p>以下方法返回值必须与使过的布局算法的输出数值一致：</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">double getMinIntrinsicWidth(BoxConstraints constraints)</code>  的返回值必须在给定约束的高度以下，使得当在宽度的约束变小时不会增加结果的高度,或者,换句话说，这个盒子可以在完全的把孩子们放在自己的里面的最小渲染宽度。</p>

        <p>例如，像 “a b cd e” 这样的文本的最小固有宽度，允许文本空格处换行，the minimum intrinsic width 应该是”cd”的宽度。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">double getMaxIntrinsicWidth(BoxConstraints constraints)</code>  的返回值必须在给定约束的宽度以上，使得当在宽度的约束变大时不会降低结果的高度。</p>

        <p>例如，像 “a b cd e” 这样的文本的最大固有宽度，允许文本空格处换行，the maximum intrinsic width 将是没有换行的 “a b cd e” 字符串整体的宽度。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">double getMinIntrinsicHeight(BoxConstraints constraints)</code> 的返回值必须在给定约束的高度以下，使得当在高度的约束变小时不会增加结果的宽度，或者,换句话说，这个盒子可以在完全的把孩子们放在自己的里面的最短渲染高度。</p>

        <p>宽高算法中的最小固有高度，像英文文本布局一样，将是给定宽度约束条件的文本的高度 。举例来说，给到 “hello world” 文本，如果约束条件是它必须在空格处换行，那么最小固有高度将是两行的高度（加上适当的行间距）。如果满足了约束条件后全部一行，那么它就是一行的高度。</p>
      </li>
      <li>
        <p><code class="highlighter-rouge">double getMaxIntrinsicHeight(BoxConstraints constraints)</code>  的返回值必须在给定约束的高度以上，使得当在高度的约束变小时不会减少结果的宽度，如果高度完全取决于宽度，而宽度不取决于高度，则给 <code class="highlighter-rouge">getMinIntrinsicHeight()</code> 和 <code class="highlighter-rouge">getMaxIntrinsicHeight()</code> 相同约束
将返回相同的数值。</p>

        <p>在英文文本的中，最大固有高度与最小固有高度相同。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>盒子中必须有一个 <code class="highlighter-rouge">performLayout()</code> 方法来封装这个类显示时布局算法。
它负责告诉孩子们如何布局，布置孩子位置，并且,如果 sizedByParent 返回 false，还要计算对象的大小。</p>

    <p>具体来说，该方法必须遍历对象的子对象（如果有的话），
并且为每个子对象调用 <code class="highlighter-rouge">child.layout()</code> 并把 BoxConstraints 对象的作为第一个参数的，
第二个参数名为 <code class="highlighter-rouge">parentUsesSize</code>，如果孩子大小的结果将会以任何方式影响布局则 <code class="highlighter-rouge">parentUsesSize</code> 必须为 true，
如果孩子的结果大小是被忽略的，则省略掉（或设为 false）。
还必须设置孩子的位置(<code class="highlighter-rouge">child.parentData.position</code>) 。</p>

    <p>（调用 <code class="highlighter-rouge">layout()</code> 可以导致孩子自己的 <code class="highlighter-rouge">performLayout()</code> 方法被递归地调用，如果孩子也需要布局的话
。如果孩子的约束没有改变，并且孩子没有被标记为需要布局，该方法将被跳过。）</p>

    <p>父节点不得直接设置孩子的 <code class="highlighter-rouge">size</code>。
如果父节点想要影响子节点的尺寸，那么必须通过传递给孩子 <code class="highlighter-rouge">layout()</code> 方法的约束来实现。</p>

    <p>如果对象的 <code class="highlighter-rouge">sizedByParent</code> 为 false，
则其 <code class="highlighter-rouge">performLayout()</code> 也必须测量对象的大小（通过设置 <code class="highlighter-rouge">size</code>），否则，对象的大小将不改变。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">size</code> 值不能设置为无限大。</p>
  </li>
  <li>
    <p>该盒子还必须实现 <code class="highlighter-rouge">hitTestChildren()</code>。
TODO(ianh): 定义这个更好</p>
  </li>
  <li>
    <p>该盒子还必须实现<code class="highlighter-rouge">paint()</code>。
TODO(ianh): 定义这个更好</p>
  </li>
</ul>

<h4 id="renderproxybox-的使用">RenderProxyBox 的使用</h4>

<h3 id="hit-testing-的协议">Hit Testing 的协议</h3>

<h2 id="性能经验法则">性能经验法则</h2>

<ul>
  <li>
    <p>如果只是简单的计算就足够请避免使用 transforms 
（例如，在 x，y 处绘制矩形，而不是用 x，y 进行平移并在 0,0 处绘制）。</p>
  </li>
  <li>
    <p>避免在画布上使用 save/restore。</p>
  </li>
</ul>

<h2 id="有用的调试工具">有用的调试工具</h2>

<p>这是一种快速方式将整个渲染树每帧转存到控制台上。
这在确定使用渲染树工作时究竟发生了什么非常有用。</p>

<div class="language-dart highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="s">'package:flutter/rendering.dart'</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">RendererBinding</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">addPersistentFrameCallback</span><span class="o">((</span><span class="n">_</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这样会转存整个渲染树的每一帧</span>
    <span class="n">debugDumpRenderTree</span><span class="o">();</span>
  <span class="o">});</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre>
</div>

</article>

          </div>
        </div>

        

      </div> <!-- /.row -->
    </div> <!-- /.container -->

    <footer class="site-footer">
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-12">
        <div class="logo">
          <img src="/images/flutter-mark-square-100.png" alt="Flutter Logo" width="100" height="100">
        </div>
        <p class="site-footer__link-list">
          <a href="https://groups.google.com/forum/#!forum/flutter-dev">flutter-dev@</a> &bull;
          <a href="https://twitter.com/flutterio">twitter</a> &bull;
          <a href="https://github.com/flutter/">github</a> &bull;
          <a href="/tos">terms</a> &bull;
          <a href="https://www.google.com/intl/en/policies/privacy/">privacy</a> &bull;
          <a href="https://github.com/orgs/flutter-dev/teams/flutter/">翻译组</a>
        </p>

        <p class="licenses">
          除非另有说明，否则本作品根据
          <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可证</a>进行许可，代码示例已根据 BSD 许可证进行许可。
        </p>
      </div>
    </div>
  </div>
</footer>

    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="/js/sidebar_toggle.js"></script>
    <script src="/js/customscripts.js"></script>
    <script src="/js/prism.js"></script>
    <script src="/js/tabs.js"></script>
    <script src="/js/archive.js"></script>
    
    <script async="" defer="" src="//survey.g.doubleclick.net/async_survey?site=at3ul57xpub2vk3oxt2ytw365i"></script>
  </body>
</html>
